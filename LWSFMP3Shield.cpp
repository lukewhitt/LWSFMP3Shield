/*******************************************************************************
 Sparkfun Electronics MP3 Shield Library
	based off library found at: http://billporter.info/?p=1270
	also used improvements found in Nathan Seidle's code: http://bit.ly/PIVjpm

	SparkFun DEV-09736 MP3 Shield (WITHOUT SD slot)
	Uses the VS1053 IC chip, may work with others, untested.

	Luke Whittington, 2012

	Debugging is done at 115200bps.
	The examples will use an embedded MP3 file (no SD card necessary)
	and streaming via WIFI shield.
	
	The flow of data is controlled by two pins:
	xDCS: Pull low to send data
	xCS: Pull low to send control commands
	
	From now on, xCS (aka *CS) will be called CS. The x just means it's active low
	which will be taken care of in firmware.
	
	We can also remove the need for DCS by setting SM_SDISHARE = 1. DCS signal is 
	internally generated by inverting CS input. However, if we want to hook up an external
	SD card, this is a bad idea. The reason is that if we combine the two pins (CS and DCS)
	then we always have to be in one of the modes (either data or control). This isn't a
	good idea since we need to get the VS1053 off the SPI bus so we can go grab data from
	the SD card.
	
	4 pins required to control the VS1053 IC:
	DREQ
	CS
	DCS
	Reset (optional, but always good to have reset)
	And the SPI bus.

	Available under WTFPL:

	DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
                    Version 2, December 2004

 Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>

 Everyone is permitted to copy and distribute verbatim or modified
 copies of this license document, and changing it is allowed as long
 as the name is changed.

            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. You just DO WHAT THE FUCK YOU WANT TO.

*******************************************************************************/

#include "LWSFMP3Shield.h"
#include <SPI.h>
#include <avr/pgmspace.h>



//bitrate lookup table
// 168 bytes; best store in PROGMEM or EEPROM
PROGMEM prog_uint16_t bitrate_table[14][6] = 
{
	{0,0,0,0,0,0},
	{32,32,32,32,8,8}, //0001
	{64,48,40,48,16,16}, //0010
	{96,56,48,56,24,24}, //0011
	{128,64,56,64,32,32}, //0100
	{160,80,64,80,40,40}, //0101
	{192,96,80,96,48,48}, //0110
	{224,112,96,112,56,56}, //0111
	{256,128,112,128,64,64}, //1000
	{288,160,128,144,80,80}, //1001
	{320,192,160,160,96,69}, //1010
	{352,224,192,176,112,112}, //1011
	{384,256,224,192,128,128}, //1100
	{416,320,256,224,144,144} 
};//1101


uint8_t LWSFMP3Shield::begin(){
	pinMode(MP3_DREQ, INPUT);
	pinMode(MP3_XCS, OUTPUT);
	pinMode(MP3_XDCS, OUTPUT);
	pinMode(MP3_RESET, OUTPUT);
	
	digitalWrite(MP3_XCS, HIGH); // deselect Control pin
	digitalWrite(MP3_XDCS, HIGH); // deselect Data pin
	digitalWrite(MP3_RESET, LOW); // Puts VS1053 chip into Hardware Reset
	
	Serial.begin(115200);
	Serial.println("MP3 Shield Example");
	
	// Setup SPI for VS1053
	pinMode(10, OUTPUT); // Pin 10 must be set as output for SPI communication to work
	SPI.begin();
	SPI.setBitOrder(MSBFIRST);
	SPI.setDataMode(SPI_MODE0);
	
	SPI.setClockDivider(SPI_CLOCK_DIV16); //SPI bus speed 1MHz (16MHz / 16 = 1MHz)
	SPI.transfer(0xFF); // Throws dummy byte at the bus.
	
	delay(10);
	digitalWrite(MP3_RESET, HIGH); //brings up the VS1053 chip
	
	// set initial volume
	LWSFMP3Shield::SetVolume(40,40);
	VolL = 40;
	VolR = 40;
	
	int MP3Mode = Mp3ReadRegister(SCI_MODE);
	int MP3Status = Mp3ReadRegister(SCI_STATUS);
	int MP3Clock = Mp3ReadRegister(SCI_CLOCKF);
	
	int vsVersion = (MP3Status >> 4) & 0x00F;
	Serial.print("VS Version (VS1053 is 4) = ");
	Serial.println(vsVersion, DEC);
	
	Mp3WriteRegister(SCI_CLOCKF, 0x60, 0x00); //Set multipler to 3.0x
	
	//From page 12 of datasheet, max SCI reads are CLKI/7. Input clock is 12.288MHz.
	//Internal clock multipler is now 3x.
	//Therefore, max SPI speed is 5MHz. 4MHz will be safe.
	SPI.setClockDivider(SPI_CLOCK_DIV4);
	MP3Clock = Mp3ReadRegister(SCI_CLOCKF);
	return 0;
}

void LWSFMP3Shield::SetVolume(unsigned char leftChan, unsigned char rightChan){
	VolL = leftChan;
	VolR = rightChan;
	
	Mp3WriteRegister(SCI_VOL, leftChan, rightChan);
}

uint8_t LWSFMP3Shield::playMP3(unsigned char[]* mp3)
{
	unsigned char *p;
	p = &mp3[0] //point p at the start of array
	while (p <= &mp3[sizeof(mp3)-1]){
		while(!digitalRead(MP3_DREQ)){
			// IC is free. Can do other crap here.
		}
		
		digitalWrite(MP3_XDCS, LOW); // Select Data pin
		SPI.transfer(*p++); // Send SPI Byte
		digitalWrite(MP_XDCS, HIGH); // deselect data
	}
	
	//End of file, send silence before next file
	digitalWrite(MP3_XDCS, LOW);
	for (int i=0;i<2048;i++){
		while(!digitalRead(MP3_DREQ)); // If we ever see DREQ low, then we wait here
		SPI.transfer(0);
	}
	while(!digitalRead(MP3_DREQ)); // Wait for high, indicating transfer is complete
	digitalWrite(MP3_XDCS, HIGH); //Deselect data
	
	return 0;
}

unsigned int Mp3ReadRegister(unsigned char addressByte){
	if (playing)
		detachInterrupt(0);
	
	while(!digitalRead(MP3_DREQ)); // wait for IC to be ready
	digitalWrite(MP3_XCS, LOW); // Select control
	
	SPI.transfer(0x03); // Read instruction
	SPI.transfer(addressByte);
	
	char response1 = SPI.transfer(0xFF); // Read first byte
	while(!digitalRead(MP3_DREQ)); // wait for IC
	char response2 = SPI.transfer(0xFF); // Read second byte
	while(!digitalRead(MP3_DREQ)); // wait for IC
	
	digitalWrite(MP3_XCS, HIGH); // deselect control pin
	
	int resultValue = response1 << 8;
	resultValue |= response2;
	return resultValue;
	
	if(playing){
		refill();
		attachInterrupt(0,refill, RISING);
	}
}

void Mp3WriteRegister(unsigned char addressByte, unsigned char highByte, unsigned char lowByte){
	if (playing)
	detachInterrupt(0);
	
	// Waits for DREQ to go high, indicated the IC is ready
	while(!digitalRead(MP3_DREQ));
	digitalWrite(MP3_XCS, LOW);
	
	//SCI consists of instruction byte, address byte and 16-bit data word.
	SPI.transfer(0x02);
	SPI.transfer(addressByte);
	SPI.transfer(highByte);
	SPI.transfer(lowByte);
	while(!digitalRead(MP3_DREQ)); // Wait again for DREQ to be high
	digitalWrite(MP3_XCS, HIGH); // deselect control
	
	// resume interrupt if playing
	if (playing){
		refill();
		//attach refill interrupt off DREQ line, pin 2
		attachInterrupt(0, refill, RISING);
	}
	}
	
static void refill(){
	while(digitalRead(MP3_DREQ)){
		//TODO: Try to read next 32 bytes of song
	}
}
	

